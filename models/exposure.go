package models

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/sophie-rigg/havs-service/utils"
	"time"
)

var (
	ErrorExposureInvalid = "exposure is invalid, missing: %s"

	ErrorInvalidExposureRequest = errors.New("invalid exposure request")
)

type ExposurePostRequestBody struct {
	EquipmentID string `json:"equipment_id"` // uuid
	Duration    int    `json:"duration"`     // minutes
	UserID      string `json:"user_id"`      // uuid
}

type Exposure struct {
	ID        string         `json:"id" bson:"_id"` // uuid
	Equipment *EquipmentItem `json:"equipment,omitempty" bson:"equipment"`
	Duration  int            `json:"duration" bson:"duration"` // minutes
	A8        float64        `json:"a8" bson:"a8"`
	Points    float64        `json:"points" bson:"points"`
	User      *User          `json:"user" bson:"user"`
	// currently this is a timestamp generated by the service
	// in the future, this should be a timestamp provided by the client for a more accurate representation of the exposure
	CreatedTime time.Time `json:"created_time" bson:"created_time"`
}

// NewExposureFromRequestBody creates a new exposure, from JSON byte array.
func NewExposureFromRequestBody(data []byte) (*Exposure, error) {
	var exposureRequest ExposurePostRequestBody

	if err := json.Unmarshal(data, &exposureRequest); err != nil {
		return nil, err
	}

	exposure := exposureRequest.ToExposure()

	// Generate timestamp and ID
	exposure.GenerateTimestamp()
	if err := exposure.GenerateID(); err != nil {
		return nil, err
	}

	// We will save a record of when the exposure was created along with an ID even if the exposure is invalid
	// This will allow us to track when the exposure was created and potentially recover the exposure later
	if !exposureRequest.Valid() {
		return exposure, ErrorInvalidExposureRequest
	}

	return exposure, nil
}

func (e *ExposurePostRequestBody) ToExposure() *Exposure {
	return &Exposure{
		Equipment: NewEquipmentItem(e.EquipmentID),
		Duration:  e.Duration,
		User:      NewUser(e.UserID),
	}
}

func (e *Exposure) SetEquipment(equipment *EquipmentItem) {
	e.Equipment = equipment
}

func (e *Exposure) SetUser(user *User) {
	e.User = user
}

func (e *ExposurePostRequestBody) Valid() bool {
	return e.EquipmentID != "" && e.Duration > 0 && e.UserID != ""
}

func (e *Exposure) ToJSON() ([]byte, error) {
	return json.Marshal(e)
}

// CalculateExposure calculates the exposure points and A8 for the exposure.
func (e *Exposure) CalculateExposure() error {
	if e.Equipment.VibrationalMagnitude == 0 {
		return fmt.Errorf(ErrorExposureInvalid, "vibrational magnitude")
	}

	if e.Duration == 0 {
		return fmt.Errorf(ErrorExposureInvalid, "duration")
	}
	e.A8 = utils.PartialExposureA8(e.Equipment.VibrationalMagnitude, e.Duration)
	e.Points = utils.PartialExposurePoints(e.Equipment.VibrationalMagnitude, e.Duration)

	return nil
}

// GenerateTimestamp generates a timestamp for the exposure.
func (e *Exposure) GenerateTimestamp() {
	e.CreatedTime = time.Now().Round(time.Second)
}

// GenerateID generates a UUID for the exposure.
func (e *Exposure) GenerateID() error {
	if e.ID != "" {
		return nil
	}

	id, err := utils.GenerateUUID()
	if err != nil {
		return err
	}

	e.ID = id
	return nil
}
